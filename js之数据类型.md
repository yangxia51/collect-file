
原始(基本)类型
 0.string
 1.number
 2.undefined
 3.null
 4.symol
 5.boolean
 特点：
 0.原始类型存储的是值
 1.原始类型没有函数可调用
 2.原始类型中boolean、Number、String为什么可以调用对象函数？当调用时，强行转化为对象类型，为它创建了一个对应的包装类型,让这个实例去调用指定方法,使用完毕后立即销毁改对象，不会改变对象类型，反而言之不能为基本类型值添加自定义属性和方法。
 3.number浮点型 0.1+0.2 ！= 0.3 (计算机处理数据是二进制,在转化为二进制相加,再逆向转十进制中导致不等于0.3)
 4.typeof null 为什么等于 object? null的二进制表示是全0,二进制前三位自然数为0，就判定是object
 5.undefined/null？ 
   0)在if中都会被自动转化为false 
   1)undefined表示未定义，此处有值，转为数值时为NaN
   3)null表示尚未存在的对象，转为数值时为0


 引用类型(对象类型)
 除了原始类型都是引用类型
 0.引用类型存储的是地址(指针)
 1.变量赋值给另外一个变量的时候 修改其中一个值会导致两个变量的值都发生变化
 2.typeof判断类型是否靠谱？ 
   不靠谱 
   0)判定null函数为object
   1)引用对象判定除了函数都会判断为object
 3.判断类型instanceof
   靠谱
   0)通过原型链判断 
   注：原始类型的判断要先转换为实例对象
 
 基础类型和引用类型的区别？

 js类型转换
一、转换为字符串
0)toString() 不可以转换null和underfined
1)Striong()

二、转换为数字
0) Number() 
1) parseint() 
2) parseFloat()

三、转换为布尔值
0) Boolean()
1) if(){}  判断执行 
在条件判断下，除了undefined，null，false,NaN,'',0,-0其他所有字都转为true,包括所有对象

四则运算
0、加法
0)运算中其中一方为字符串，那么就会把另一方也转换字符串
1)如果一方不是字符串或者数字，那么会将它转换为数字或者字符串
注：除了加法运算符，只要其中一方是数字另外一方就会被当成数字计算


==和===
== 不同类型会转换类型
=== 不会转换类型 会直接比较

[]==![] 比较过程？
1、根据运算符!比==高  计算![] 逻辑！将变量换成布尔类型 ![] =false
2、根据如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1
3、比较[]==0 根据如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较，如果对象没有valueOf()方法，则调用 toString() 对于空数组空数组，[].toString() ->''
4、 ''==0  根据如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值 Number('')=0
5、 0==0 true
总结：[] == ! []   ->   [] == false  ->  [] == 0  ->   '' == 0   ->  0 == 0   ->  true


{}==!{} 比较过程？
{}=!{}->{}==false->{}==0->NaN==0->false
注意：{}->toString = NaN
 

